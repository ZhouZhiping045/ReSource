id,function_name,code
1,PCXWritePixels,"uint64_t PCXWritePixels(PCXImage *image, uint8_t *pixels, FILE *stream) { for (uint8_t y = 0; y < image->height; ++y) { if (image->compressed) { uint8_t current_pixel = *pixels++; uint8_t count = 1; for (uint16_t x = 0; x < image->width - 1; ++x) { uint8_t next_pixel = *pixels++; if (next_pixel == current_pixel && count < PCX_RLE_MAX_COUNT) { count++; continue; } if (count > 1 || (current_pixel & PCX_RLE_MASK)) { WriteBlobByte(stream, count | PCX_RLE_MASK); } WriteBlobByte(stream, current_pixel); current_pixel = next_pixel; count = 1; } if (count > 1 || (current_pixel & PCX_RLE_MASK)) { WriteBlobByte(stream, count | PCX_RLE_MASK); } WriteBlobByte(stream, current_pixel); } else { for (uint16_t x = 0; x < image->width; ++x) { WriteBlobByte(stream, *pixels++); } } } return PCX_SUCCESS; }"
2,c_escape,char* c_escape(const char* input) { const char* src = input; const char* orig = src; int encoded_len = 0; bool needs_quote = false; while (*src) { if (*src == ' ') needs_quote = true; encoded_len += c_escape_char(*src) ? OCTAL_ESCAPE_EXTRA : SIMPLE_ESCAPE_EXTRA; src++; } if (!needs_quote && encoded_len == (src - orig)) { return (char*)orig; } size_t total_size = (src - orig) + encoded_len + QUOTED_EXTRA; char* buffer = xmalloc(total_size); char* dst = buffer; *dst++ = '""'; src = orig; while (*src) { char esc_code = c_escape_char(*src); if (esc_code) { *dst++ = '\\'; if (esc_code == 1) { *dst++ = ((*src >> 6) & 0x03) + OCTAL_DIGIT_BASE; *dst++ = ((*src >> 3) & 0x07) + OCTAL_DIGIT_BASE; *dst++ = (*src & 0x07) + OCTAL_DIGIT_BASE; } else { *dst++ = esc_code; } } else { *dst++ = *src; } src++; } *dst++ = '""'; *dst = '\0'; return buffer; }
