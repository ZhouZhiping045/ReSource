static MagickBooleanType PCXWritePixels(PCXInfo *pcx_info,
const unsigned char *pixels,Image *image)
{
register const unsigned char
*q;
register ssize_t
i,
x;
ssize_t
count;
unsigned char
packet,
previous;
q=pixels;
for (i=0; i < (ssize_t) pcx_info->planes; i++)
{
if (pcx_info->encoding == 0)
{
for (x=0; x < (ssize_t) pcx_info->bytes_per_line; x++)
(void) WriteBlobByte(image,(unsigned char) (*q++));
}
else
{
previous=(*q++);
count=1;
for (x=0; x < (ssize_t) (pcx_info->bytes_per_line-1); x++)
{
packet=(*q++);
if ((packet == previous) && (count < 63))
{
count++;
continue;
}
if ((count > 1) || ((previous & 0xc0) == 0xc0))
{
count|=0xc0;
(void) WriteBlobByte(image,(unsigned char) count);
}
(void) WriteBlobByte(image,previous);
previous=packet;
count=1;
}
if ((count > 1) || ((previous & 0xc0) == 0xc0))
{
count|=0xc0;
(void) WriteBlobByte(image,(unsigned char) count);
}
(void) WriteBlobByte(image,previous);
}
}
return (MagickTrue);
}
/////
static char *
c_escape (char const *str)
{
char const *s;
size_t plus = 0;
bool must_quote = false;
for (s = str; *s; s++)
{
char c = *s;
if (c == ' ')
{
must_quote = true;
continue;
}
switch (c_escape_char (*s))
{
case 1:
plus += 3;
case 0:
break;
default:
plus++;
break;
}
}
if (must_quote || plus)
{
size_t s_len = s - str;
char *buffer = xmalloc (s_len + plus + 3);
char *b = buffer;
*b++ = '"';
for (s = str; *s; s++)
{
char c = *s;
char escape = c_escape_char (c);
switch (escape)
{
case 0:
*b++ = c;
break;
case 1:
*b++ = '\\';
*b++ = ((c >> 6) & 03) + '0';
*b++ = ((c >> 3) & 07) + '0';
*b++ = ((c >> 0) & 07) + '0';
break;
default:
*b++ = '\\';
*b++ = escape;
break;
}
}
*b++ = '"';
*b = 0;
return buffer;
}
return (char *) str;
}