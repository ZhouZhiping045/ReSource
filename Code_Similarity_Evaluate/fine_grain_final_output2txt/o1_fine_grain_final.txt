int PCXWritePixels(PCXImage *image, unsigned char *pixels, void *blob) { if (!image->pack) { for (int row = 0; row < image->rows; row++) { unsigned char *current = pixels; if (!image->previous) { for (int col = 0; col < image->columns; col++) { WriteBlobByte(blob, current[col]); } pixels += image->columns; continue; } unsigned char value = *current++; int run_length = 1; for (int col = 1; col < image->columns; col++, current++) { if (*current == value && run_length < PCX_MAX_RUN) { run_length++; } else { if (run_length > 1 || (value & PCX_RLE_MASK)) { WriteBlobByte(blob, run_length | PCX_RLE_MASK); } WriteBlobByte(blob, value); value = *current; run_length = 1; } } if (run_length > 1 || (value & PCX_RLE_MASK)) { WriteBlobByte(blob, run_length | PCX_RLE_MASK); } WriteBlobByte(blob, value); pixels += image->columns; } } return 1; }
/////
char* c_escape(const char* input_str) { const char* current; char ch; int need_quote = 0; size_t expansion = 0; for (current = input_str; (ch = *current); ++current) { if (ch == ' ') { need_quote = 1; } else { char esc = c_escape_char(ch); expansion += esc ? (esc == OCTAL_ESCAPE ? 3 : 1) : 0; } } if (!expansion && !need_quote) { return (char*)input_str; } char* buffer = xmalloc(strlen(input_str) + expansion + QUOTE_EXTRA); char* dest = buffer; *dest++ = '"'; for (const char* p = input_str; *p; ++p) { char code = c_escape_char(*p); if (!code) { *dest++ = *p; continue; } *dest++ = '\\'; if (code == OCTAL_ESCAPE) { *dest++ = ((*p >> 6) & 7) + '0'; *dest++ = ((*p >> 3) & 7) + '0'; *dest++ = (*p & 7) + '0'; } else { *dest++ = code; } } *dest++ = '"'; *dest = '\0'; return buffer; }
