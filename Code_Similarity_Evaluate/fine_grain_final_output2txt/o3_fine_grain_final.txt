bool WritePixels(PCXContext *ctx, uint8_t *pixels, FILE *output) { for (uint8_t plane = 0; plane < ctx->colorPlanes; ++plane) { uint16_t bytes = ctx->bytesPerLine; if (!ctx->encoding) { fwrite(pixels, 1, bytes, output); pixels += bytes; continue; } uint8_t *end = pixels + bytes; uint8_t current = *pixels++; if (bytes == 1) { fputc(current, output); continue; } uint8_t run = 1; while (pixels < end) { if (*pixels == current && run <= MAX_RUN_LENGTH) { run++; pixels++; continue; } if (run > 1 || (current & PCX_RLE_MASK)) { fputc(run | PCX_RLE_MASK, output); } fputc(current, output); current = *pixels++; run = 1; } if (run > 1 || (current & PCX_RLE_MASK)) { fputc(run | PCX_RLE_MASK, output); } fputc(current, output); } return true; }
/////
char *c_escape(const char *str) { if (!str || !*str) { char *result = strdup(str ? str : ""); return result; } size_t escape_chars = 0; int has_space = 0; const char *p; for (p = str; *p; p++) { unsigned char c = *p; if (c == ' ') { has_space = 1; } else if (c == '"' || c == '\\') { escape_chars++; } else if (c < 32) { if (c >= '\a' && c <= '\r') { escape_chars++; } else { escape_chars += 3; } } } if (!escape_chars && !has_space) { return strdup(str); } size_t total_len = (p - str) + escape_chars + 3; char *buffer = malloc(total_len); if (!buffer) return NULL; char *dest = buffer; *dest++ = '"'; for (p = str; *p; p++) { switch (*p) { case '\a': *dest++ = '\\'; *dest++ = 'a'; break; case '\b': *dest++ = '\\'; *dest++ = 'b'; break; case '\t': *dest++ = '\\'; *dest++ = 't'; break; case '\n': *dest++ = '\\'; *dest++ = 'n'; break; case '\v': *dest++ = '\\'; *dest++ = 'v'; break; case '\f': *dest++ = '\\'; *dest++ = 'f'; break; case '\r': *dest++ = '\\'; *dest++ = 'r'; break; case '"': case '\\': *dest++ = '\\'; *dest++ = *p; break; default: if (*p >= 32) { *dest++ = *p; } else { *dest++ = '\\'; dest[0] = '0' + ((*p >> 6) & 3); dest[1] = '0' + ((*p >> 3) & 7); dest[2] = '0' + (*p & 7); dest += 3; } break; } } *dest++ = '"'; *dest = '\0'; return buffer; }
